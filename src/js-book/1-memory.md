---
  category: JS
---

# 内存/堆栈

## 类型

- stack栈(LIFO，后进先出)

  基本类型:  占用内存空间大小固定，按值直接访问

  ```js
  undefined, null, boolean, number, string, symbol
  ```

- heap堆(key-value，顺序无关)

  引用类型:  占用内存空间大小不固定但内存地址大小固定，内存地址存储于栈中，访问时先从栈内读取内存地址，再从堆中寻找对应值

- 池(一般归为栈中，存放常量用)

- 队列(FIFO，先进先出)

## 生命周期

- 栈: 自动分配，自动释放

- 堆: 手动分配，手动释放

1. 分配所需内存

2. 使用分配到的内存进行读写操作

3. 读写完毕，释放内存(垃圾回收)

## 垃圾回收

- 标记清除(主流)

  从根部（全局对象）出发定时扫描内存中的对象，若能从根部到达则保留，反之标记为不再使用，稍后进行统一回收

- 引用计数(大多已废弃，致命问题：循环引用)

  给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就不可再被访问，因此可以被回收

- 变量类型
  - 局部变量(局部作用域中，函数执行完就可回收局部变量)
  - 全局变量(全局作用域中很难判断何时回收，因此要避免使用全局变量)
  - 无需计入垃圾回收的变量类型(WeakSet / WeakMap)

## 内存泄漏

  > 对于持续运行的服务进程（daemon）必须及时释放无需用到的内存，否则内存占用越来越高，轻则影响性能，重则进程崩溃

### 排查方法

- 浏览器

  1. 打开开发者工具，选择 Memory
  2. 在右侧的 Select profiling type 中勾选 timeline
  3. 点击左上角的录制按钮
  4. 在页面上模拟正常用户的各种操作
  5. 一段时间后，点击左上角的stop按钮，然后查看面板上这段时间内的内存使用情况

- Node.js

  1. 使用 nodejs 提供的 process.memoryUsage()
  2. 以 heapUsed 字段来判定内存泄漏

### 常见原因

- 意外的全局变量

  - 未定义的变量会在全局对象下创建一个新变量或函数内的 this 在调用时指向了全局对象
  - 若必须使用全局变量存储数据，要确保使用完之后设置为 null，或重新定义；使用 use strict 严格模式，此时调用函数内本来指向全局的 this 会指向 undefined，从而避免意外的全局变量

- 被遗忘的计时器或回调函数

  - 设置计时器后没有清除或DOM事件的循环引用
  - 及时清除不再使用的计时器；addEventListener 之后若关联的对象不再使用需要调用 removeEventListener 解绑事件（针对引用计数的老IE，现代浏览器使用标记清除，可以不必调用）

- 脱离 DOM 的引用

  - 将获取到的DOM存储成字典（JSON键值对）或者数组，此时同样的DOM元素会存在两个引用，一个在DOM树中，一个在字典中
  - DOM树与字典中的引用都需要清除掉

- 闭包
  - 闭包的函数体内会存在对上层作用域中变量的引用，此时若上层作用域中的变量被释放，那么闭包中的变量也会被释放，从而导致内存泄漏
  - 及时释放不再使用的闭包

---
  category: JS
---

# 作用域/作用域链/闭包

## 作用域

> 指一个变量或函数的作用范围

- 函数内声明的所有变量在函数体内始终可见
- 变量提升（var 声明的变量会提升到作用域顶层并赋值 undefined, let 与 const 则不会提升）
- ES6之前有全局与局部作用域，没有块级作用域（catch作用域只在其内部生效）
- 局部作用域（变量）的优先级高于全局作用域（变量）

## 作用域链

> 当访问一个变量时，解析器会首先在当前作用域内查找标识符，如果没有找到，就去父级作用域查找，直到找到该变量的标识符或者不在父级作用域内

- 查找一个普通对象的属性，若在作用域链内找不到则会拋出 ReferenceError 错误
- 顶端是全局对象，在全局环境中定义的变量会绑定到全局对象中
- 和原型链查找的区别：在当前对象和原型链中都找不到普通对象的属性时，会返回 undefined

### 执行

- 无嵌套的函数（全局环境下直接调用的函数）
  - 定义时，函数标识符（identifier）就被加入到全局对象中，此标识符引用的是一个函数对象（function object），并且这个函数对象不仅包括函数自身的代码，还含有指向其被创建时的作用域对象
  - 内部属性[[scope]]指向当前的作用域对象，即函数标识符被创建时能够直接访问的作用域对象（全局对象）
  - 调用时，一个新的作用域对象会被创建，该对象中包含函数定义的局部变量，以及其参数（arguments），新作用域对象的父作用域对象就是在运行函数时可以直接访问的那个作用域对象

- 有嵌套的函数（在函数内部调用的函数）
  - 当函数返回没有被引用的时候，会被垃圾回收，但对于闭包（函数嵌套）来说，即使外部函数返回了，函数对象仍旧会引用它被创建时的作用域对象，所以不会被垃圾回收
  - 当调用一个子函数，其执行上下文会维护一个作用域链，指向父函数的作用域，作用域链是一个此类结构的数组：Scope: [AO, parentFnContext.AO, globalContext.VO]\n所以即使父函数执行完后其 parentFnContext 被销毁了，Javascript 依旧会将其 AO （活动对象）保留在内存中，子函数仍然可以通过作用域链访问到其所需要的父函数的变量

## 闭包

> 闭包是指有权访问另一个函数作用域中的变量的函数

- 闭包可以访问当前函数以外的变量
- 即使外部函数已经返回，闭包仍旧可以访问外部函数定义的变量
- 闭包可以更新外部变量的值

---
  category: Javascript
---

# JS 运行机制

:::tip
单线程？任务队列？事件循环？
:::

## 单线程

在 JS 引擎中，解析执行 JS 代码的调用栈是唯一的，所有的 JS 代码都在这一个调用栈里按照调用顺序执行，不能同时执行多个函数，调用栈遵循 LIFO(last in first out 后进先出)的规则，只有栈顶的函数处理完成后出栈，后面的函数再进入栈顶被执行。

## 任务队列

由于 JS 引擎的单线程设定同一时间只能执行一个任务，所有的任务都需要排队等待被引擎执行，所以如果其中某个任务耗时很长，后面的任务就必须一直等待，为解决这一问题，设计者将所有任务分为两种，同步与异步。

同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。

异步任务：不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

异步任务一般有：

- `setTimeout(fn, time)`、`setInterval(fn, time)`
  - 当 `time` 参数值缺省时，默认为 0
  - 当 `time` 指定的值小于 4 时，增加到 4，即至少需要 4 毫秒，此定时器才会进入任务队列
- DOM 事件
- Ajax 异步与 Promise

==在所有同步任务执行完之前，任何的异步任务是不会执行的==

## 事件循环

异步任务的执行机制：

1. 所有同步任务都在主线程上执行，形成一个执行栈(execution context stack)
2. 主线程之外，还存在一个"任务队列"(task queue)，只要异步任务有了运行结果，就在"任务队列"之中放置一个事件
3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件，那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行
4. 主线程不断重复上面的第三步

==主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。只要主线程空了，就会去读取"任务队列"，这就是 JavaScript 的运行机制。==

## 异步任务分类

异步任务可以分为宏任务和微任务，宏任务队列可以有多个，微任务队列只有一个。

宏任务: `script(整体代码)`，`setTimeout`，`setInterval`，`setImmediate`(Node)，`I/O`，`UI rendering`，`postMessage`

微任务: `new Promise().then(回调)`，`process.nextTick`，`Object.observe` (已废弃)，`MutationObserver` (html5 新特性)

执行顺序：

1. 由于执行代码入口都是全局任务 `script`，而全局任务属于宏任务，所以先执行宏任务。当栈为空，同步任务执行完毕时，会先执行微任务队列里的任务
2. 微任务队列里的任务全部执行完毕后，会读取宏任务队列中排队最前的任务
3. 执行宏任务的过程中，遇到微任务，依次加入微任务队列
4. 栈空后，再次读取微任务队列里的任务，依次类推

==当某个宏任务队列的中的任务全部执行完以后，会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，就查看是否有其他宏任务队列==

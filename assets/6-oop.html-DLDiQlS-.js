import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e as t}from"./app-CgZv1aOY.js";const p={},e=t(`<h1 id="面向对象" tabindex="-1"><a class="header-anchor" href="#面向对象"><span>面向对象</span></a></h1><div class="hint-container tip"><p class="hint-container-title">提示</p><p>JS 面向对象的原理？如何声明与实例化？如何继承？</p></div><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><p>JS 的对象体系，不是基于“类”，而是基于构造函数 <code>constructor</code> 与原型链 <code>prototype</code></p><h2 id="声明与实例化" tabindex="-1"><a class="header-anchor" href="#声明与实例化"><span>声明与实例化</span></a></h2><p>类的声明一般区分 <em>ES5</em> 与 <em>ES6</em> 两种方式，类名一般都遵循首字母大写的约定</p><ul><li><p>ES5</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">World</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>greeting <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>ES6</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">World2</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>通过 <code>new</code> 运算符来实例化，如果一个类没有参数，则可以省略括号</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">World</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">World2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="类的继承" tabindex="-1"><a class="header-anchor" href="#类的继承"><span>类的继承</span></a></h2><p>类的继承区分 <em>ES5</em> 与 <em>ES6</em> 两种方式，其中</p><ul><li><p>ES6 采用关键字 <code>extends</code> 实现继承，使用 <code>super</code> 调用父类的构造函数</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Person 类</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">// Student 类继承至 Person 类</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&#39;李雷&#39;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
student<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>ES5 实现继承的方法较多，下面列出常见的几种</p></li></ul><h3 id="借助构造函数实现" tabindex="-1"><a class="header-anchor" href="#借助构造函数实现"><span>借助构造函数实现</span></a></h3><p><strong>原理：</strong></p><ul><li><p>JS 通过构造函数生成新对象，因此构造函数可以视为对象的模板，实例对象的属性和方法，可以定义在构造函数内部，通过改变构造函数运行时的 <code>this</code> 指向实现继承</p><p><strong>优点：</strong></p></li><li><p>父类的引用属性不会被共享</p></li><li><p>子类构建实例时可以向父类传递参数</p><p><strong>缺点：</strong></p></li><li><p>父类的方法不能复用，子类实例的方法每次都要单独创建</p></li><li><p>只能继承构造函数中已经定义的属性和方法，无法继承后续在父类的原型上添加的属性和方法，因为没有用到原型</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">ParentContructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;parent_contructor&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">ChildContructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ParentContructor</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// apply 也可以</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&#39;contructor&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="借助原型链实现" tabindex="-1"><a class="header-anchor" href="#借助原型链实现"><span>借助原型链实现</span></a></h3><p><strong>原理：</strong></p><ul><li><p>JS 中原型对象的所有属性和方法，都能被实例对象共享；即如果属性和方法定义在原型上，那么所有实例都能共享，不用新生成，因此将父类的实例作为子类的原型可以实现继承</p><p><strong>优点：</strong></p></li><li><p>父类方法可以复用</p><p><strong>缺点：</strong></p></li><li><p>父类的引用属性会被所有子类实例共享，因此如果一个子类修改了其继承而来的引用类型，其他子类对应的引用类型也会被改变</p></li><li><p>子类构建实例时不能向父类传递参数</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">ParentProtoChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;parent_protochain&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">ChildProtoChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&#39;protochain&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">ChildProtoChain</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ParentProtoChain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="组合继承" tabindex="-1"><a class="header-anchor" href="#组合继承"><span>组合继承</span></a></h3><p><strong>原理：</strong></p><ul><li><p>通过调用父类构造函数，继承父类的属性并保留传参，然后通过将父类实例作为子类实现继承</p><p><strong>优点：</strong></p></li><li><p>保留构造函数的优点：创建子类实例，可以向父类构造函数传参数</p></li><li><p>保留原型链的优点：父类的实例方法定义在父类的原型对象上，可以实现方法复用</p></li><li><p>不共享父类的引用属性</p><p><strong>缺点：</strong></p></li><li><p>由于调用了两次次父类的构造方法，会存在一份多余的父类实例属性</p></li><li><p>第一次：ChildCombine.prototype = new ParentCombine();</p></li><li><p>第二次：ParentCombine.call(this);</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">ParentCombine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;parent_combine&#39;</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">ChildCombine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ParentCombine</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&#39;combine&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">ChildCombine</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ParentCombine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="组合继承优化" tabindex="-1"><a class="header-anchor" href="#组合继承优化"><span>组合继承优化</span></a></h3><p><strong>原理：</strong></p><ul><li><p>通过将父类的原型对象赋值给子类的原型对象，避免初始化两次实例</p><p><strong>优点：</strong></p></li><li><p>保留了组合继承的优点</p></li><li><p>只调用一次父类构造函数</p><p><strong>缺点：</strong></p></li><li><p>子类修改构造函数的指向之后，父类实例的构造函数指向也会同时也发生变化，因为不能判断子类实例的直接构造函数到底是子类构造函数还是父类构造函数</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">ParentCombineOpt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;parent_combineopt&#39;</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">ChildCombineOpt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ParentCombineOpt</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&#39;combineopt&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">ChildCombineOpt</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">ParentCombineOpt</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="组合继承完美版" tabindex="-1"><a class="header-anchor" href="#组合继承完美版"><span>组合继承完美版</span></a></h3><p><strong>原理：</strong></p><ul><li><p>通过 <code>Object.create</code> 创建中间对象隔离开子类原型和父类原型</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">ParentCombinePrefect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;parent_combinePrefect&#39;</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">ChildCombinePrefect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ParentCombinePrefect</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">&#39;combinePrefect&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 隔离父子原型</span>
<span class="token class-name">ChildCombinePrefect</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">ParentCombinePrefect</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建子类自己的构造函数</span>
<span class="token class-name">ChildCombinePrefect</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> ChildCombinePrefect<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>`,27),o=[e];function c(i,l){return s(),a("div",null,o)}const d=n(p,[["render",c],["__file","6-oop.html.vue"]]),k=JSON.parse('{"path":"/interview/outline/6-oop.html","title":"面向对象","lang":"zh-CN","frontmatter":{"category":"Javascript","description":"面向对象 提示 JS 面向对象的原理？如何声明与实例化？如何继承？ 原理 JS 的对象体系，不是基于“类”，而是基于构造函数 constructor 与原型链 prototype 声明与实例化 类的声明一般区分 ES5 与 ES6 两种方式，类名一般都遵循首字母大写的约定 ES5 ES6 通过 new 运算符来实例化，如果一个类没有参数，则可以省略括号...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/fe-handbook/interview/outline/6-oop.html"}],["meta",{"property":"og:site_name","content":"HC的前端手册"}],["meta",{"property":"og:title","content":"面向对象"}],["meta",{"property":"og:description","content":"面向对象 提示 JS 面向对象的原理？如何声明与实例化？如何继承？ 原理 JS 的对象体系，不是基于“类”，而是基于构造函数 constructor 与原型链 prototype 声明与实例化 类的声明一般区分 ES5 与 ES6 两种方式，类名一般都遵循首字母大写的约定 ES5 ES6 通过 new 运算符来实例化，如果一个类没有参数，则可以省略括号..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-18T10:45:41.000Z"}],["meta",{"property":"article:author","content":"Mr.HC"}],["meta",{"property":"article:modified_time","content":"2024-02-18T10:45:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面向对象\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-18T10:45:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.HC\\"}]}"]]},"headers":[{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":2,"title":"声明与实例化","slug":"声明与实例化","link":"#声明与实例化","children":[]},{"level":2,"title":"类的继承","slug":"类的继承","link":"#类的继承","children":[{"level":3,"title":"借助构造函数实现","slug":"借助构造函数实现","link":"#借助构造函数实现","children":[]},{"level":3,"title":"借助原型链实现","slug":"借助原型链实现","link":"#借助原型链实现","children":[]},{"level":3,"title":"组合继承","slug":"组合继承","link":"#组合继承","children":[]},{"level":3,"title":"组合继承优化","slug":"组合继承优化","link":"#组合继承优化","children":[]},{"level":3,"title":"组合继承完美版","slug":"组合继承完美版","link":"#组合继承完美版","children":[]}]}],"git":{"createdTime":1708253141000,"updatedTime":1708253141000,"contributors":[{"name":"LuoHuacheng","email":"154224099@qq.com","commits":1}]},"readingTime":{"minutes":3.34,"words":1003},"filePathRelative":"interview/outline/6-oop.md","localizedDate":"2024年2月18日","autoDesc":true}');export{d as comp,k as data};

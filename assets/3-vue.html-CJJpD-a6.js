import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as l,c as t,e as i}from"./app-CgZv1aOY.js";const a={},o=i('<h1 id="vue" tabindex="-1"><a class="header-anchor" href="#vue"><span>Vue</span></a></h1><h2 id="vue的基本原理" tabindex="-1"><a class="header-anchor" href="#vue的基本原理"><span>Vue的基本原理</span></a></h2><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 <code>Object.defineProperty</code>（vue3.0使用<code>proxy</code>）将它们转为 <code>getter/setter</code>，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的<code>watcher</code>程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的<code>setter</code>被调用时，会通知<code>watcher</code>重新计算，从而致使它关联的组件得以更新</p><h2 id="双向数据绑定的原理" tabindex="-1"><a class="header-anchor" href="#双向数据绑定的原理"><span>⭐ 双向数据绑定的原理</span></a></h2><p>Vue.js 是采用<em>数据劫持</em>结合<em>发布-订阅</em>模式的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter/getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><ol><li><p>需要<code>observe</code>的数据对象进行递归遍历，包括子属性对象的属性，都加上<code>setter</code>和<code>getter</code>这样的话，给这个对象的某个值赋值，就会触发<code>setter</code>，那么就能监听到了数据变化</p></li><li><p><code>compile</code>解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p></li><li><p><code>Watcher</code>订阅者是<code>Observer</code>和<code>Compile</code>之间通信的桥梁，主要做的事情是:</p><ul><li>在自身实例化时往属性订阅器(dep)里面添加自己</li><li>自身必须有一个<code>update()</code>方法</li><li>待属性变动<code>dep.notice()</code>通知时，能调用自身的<code>update()</code>方法，并触发<code>Compile</code>中绑定的回调，则功成身退。</li></ul></li><li><p>MVVM作为数据绑定的入口，整合<code>Observer</code>、<code>Compile</code>和<code>Watcher</code>三者，通过<code>Observer</code>来监听自己的model数据变化，通过<code>Compile</code>来解析编译模板指令，最终利用Watcher搭起<code>Observer</code>和<code>Compile</code>之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p></li></ol><h2 id="使用-object-defineproperty-来进行数据劫持有什么缺点" tabindex="-1"><a class="header-anchor" href="#使用-object-defineproperty-来进行数据劫持有什么缺点"><span>使用 <code>Object.defineProperty()</code> 来进行数据劫持有什么缺点</span></a></h2><p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 <code>Object.defineProperty</code> 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p><p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 <code>Proxy</code> 对对象进行代理，从而实现数据劫持。使用 <code>Proxy</code> 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 <code>Proxy</code> 是 ES6 的语法。</p><h2 id="computed-和-watch-的区别" tabindex="-1"><a class="header-anchor" href="#computed-和-watch-的区别"><span>⭐ computed 和 watch 的区别</span></a></h2><h3 id="computed" tabindex="-1"><a class="header-anchor" href="#computed"><span>computed</span></a></h3><ul><li>它支持缓存，只有依赖的数据发生了变化，才会重新计算</li><li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li><li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li><li>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li></ul><h3 id="watch" tabindex="-1"><a class="header-anchor" href="#watch"><span>watch</span></a></h3><ul><li>它不支持缓存，数据变化时，它就会触发相应的操作</li><li>支持异步监听</li><li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li><li>当一个属性发生变化时，就需要执行相应的操作</li><li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数： <ul><li>immediate：组件加载立即触发回调函数</li><li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li></ul></li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</li><li>watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li></ul><h3 id="场景" tabindex="-1"><a class="header-anchor" href="#场景"><span>场景</span></a></h3><ul><li>当需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。</li><li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 (访问一个 API)，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul><h2 id="computed-和-methods-的区别" tabindex="-1"><a class="header-anchor" href="#computed-和-methods-的区别"><span>computed 和 methods 的区别</span></a></h2><ul><li>computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值。</li><li>method 调用总会执行该函数。</li></ul><h2 id="data为什么是一个函数而不是对象" tabindex="-1"><a class="header-anchor" href="#data为什么是一个函数而不是对象"><span>data为什么是一个函数而不是对象</span></a></h2><p>Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。</p><h2 id="对keep-alive的理解" tabindex="-1"><a class="header-anchor" href="#对keep-alive的理解"><span>⭐ 对keep-alive的理解</span></a></h2><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点"><span>特点</span></a></h3><ul><li>keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，避免重新渲染。</li><li>它有两个非常重要的生命周期钩子函数：activated和deactivated，用来得知当前组件是否处于活跃状态。</li><li>它有以下三个属性：include、exclude、max <ul><li>include 字符串或正则表达式，只有名称匹配的组件会被匹配</li><li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存</li><li>max 数字，最多可以缓存多少组件实例</li></ul></li><li>一般结合路由和动态组件一起使用，keep-alive 包裹动态组件时，会缓存不活动的组件实例。</li></ul><h3 id="主要流程" tabindex="-1"><a class="header-anchor" href="#主要流程"><span>主要流程</span></a></h3><ol><li>判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li><li>获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li><li>key生成规则，cid +&quot;∶∶&quot;+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li><li>如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li></ol><h3 id="lru缓存策略" tabindex="-1"><a class="header-anchor" href="#lru缓存策略"><span>LRU缓存策略</span></a></h3><ul><li>LRU（Least rencently used）缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。</li><li>LRU算法根据数据的历史访问记录来进行淘汰数据，其核心思想是&quot;<em>如果数据最近被访问过，那么将来被访问的几率也更高</em>&quot;。</li><li>最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶ <ul><li>新数据插入到链表头部</li><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li><li>链表满的时候，将链表尾部的数据丢弃。</li></ul></li></ul><h2 id="nexttick的原理及使用场景" tabindex="-1"><a class="header-anchor" href="#nexttick的原理及使用场景"><span>⭐ $nextTick的原理及使用场景</span></a></h2><h3 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h3><ul><li>Vue 的 nextTick 是对 JavaScript 执行原理 EventLoop 的一种应用。其核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</li><li>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理。</li></ul><h3 id="存在的原因" tabindex="-1"><a class="header-anchor" href="#存在的原因"><span>存在的原因</span></a></h3><ul><li>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染。</li><li>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要。</li></ul><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h3><ol><li>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就要将DOM2获取数据的操作写在nextTick()的回调函数中。</li><li>在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。</li></ol><h2 id="data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗" tabindex="-1"><a class="header-anchor" href="#data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗"><span>data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</span></a></h2><ul><li>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</li><li>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</li></ul><h2 id="组件通信的方法" tabindex="-1"><a class="header-anchor" href="#组件通信的方法"><span>⭐ 组件通信的方法</span></a></h2><h3 id="父子组件间通信" tabindex="-1"><a class="header-anchor" href="#父子组件间通信"><span>父子组件间通信</span></a></h3><ul><li>子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</li><li>通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。</li><li>使用 provide / inject，在父组件中通过 provide 提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide 中的数据。</li></ul><h3 id="兄弟组件间通信" tabindex="-1"><a class="header-anchor" href="#兄弟组件间通信"><span>兄弟组件间通信</span></a></h3><ul><li>使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li><li>通过 $parent / $refs 来获取到兄弟组件，也可以进行通信。</li></ul><h3 id="任意组件之间" tabindex="-1"><a class="header-anchor" href="#任意组件之间"><span>任意组件之间</span></a></h3><ul><li>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li><li>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，就需要用到状态管理器如vuex, pinia等。</li></ul><h2 id="vue-router-导航守卫有哪些" tabindex="-1"><a class="header-anchor" href="#vue-router-导航守卫有哪些"><span>Vue-router 导航守卫有哪些？</span></a></h2><ul><li>全局前置/钩子：beforeEach、beforeResolve、afterEach</li><li>路由独享的守卫：beforeEnter</li><li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li></ul><h2 id="vue3有哪些更新" tabindex="-1"><a class="header-anchor" href="#vue3有哪些更新"><span>Vue3有哪些更新？</span></a></h2><h3 id="监测机制的改变" tabindex="-1"><a class="header-anchor" href="#监测机制的改变"><span>监测机制的改变</span></a></h3><p>3.0 是基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪消除了 Vue2 当中基于 Object.defineProperty 的实现所存在的限制：</p><ol><li>检测对象属性的添加和删除</li><li>检测数组索引和长度的变更</li><li>支持 Map、Set、WeakMap 和 WeakSet</li></ol><h3 id="模板" tabindex="-1"><a class="header-anchor" href="#模板"><span>模板</span></a></h3><p>作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</p><h3 id="对象式的组件声明方式" tabindex="-1"><a class="header-anchor" href="#对象式的组件声明方式"><span>对象式的组件声明方式</span></a></h3><p>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦，3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。</p><h3 id="其他改变" tabindex="-1"><a class="header-anchor" href="#其他改变"><span>其他改变</span></a></h3><ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li><li>支持 Fragment（多个根节点）和 Teleport（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><li>基于 tree shaking 优化，提供了更多的内置功能。</li></ul><h2 id="composition-api" tabindex="-1"><a class="header-anchor" href="#composition-api"><span>Composition API</span></a></h2><h3 id="产生的原因" tabindex="-1"><a class="header-anchor" href="#产生的原因"><span>产生的原因</span></a></h3><p>在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题：</p><ol><li>由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。</li><li>Vue 组件过于依赖this上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在methods 中的this竟然指向组件实例来不指向methods所在的对象。这也使得 TypeScript 在Vue2 中很不好用。</li></ol><h3 id="与react-hooks的区别" tabindex="-1"><a class="header-anchor" href="#与react-hooks的区别"><span>与React Hooks的区别</span></a></h3><p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制：</p><ul><li>不能在循环、条件、嵌套函数中调用Hook</li><li>必须确保总是在你的React函数的顶层调用Hook</li><li>useEffect、useMemo等函数必须手动确定依赖关系</li></ul><p>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比：</p><ul><li>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢</li><li>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用</li><li>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</li></ul>',66),c=[o];function d(r,n){return l(),t("div",null,c)}const p=e(a,[["render",d],["__file","3-vue.html.vue"]]),u=JSON.parse('{"path":"/interview/details/3-vue.html","title":"Vue","lang":"zh-CN","frontmatter":{"category":"Vue","description":"Vue Vue的基本原理 当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的s...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/fe-handbook/interview/details/3-vue.html"}],["meta",{"property":"og:site_name","content":"HC的前端手册"}],["meta",{"property":"og:title","content":"Vue"}],["meta",{"property":"og:description","content":"Vue Vue的基本原理 当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的s..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-19T10:19:10.000Z"}],["meta",{"property":"article:author","content":"Mr.HC"}],["meta",{"property":"article:modified_time","content":"2024-02-19T10:19:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-19T10:19:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.HC\\"}]}"]]},"headers":[{"level":2,"title":"Vue的基本原理","slug":"vue的基本原理","link":"#vue的基本原理","children":[]},{"level":2,"title":"⭐ 双向数据绑定的原理","slug":"双向数据绑定的原理","link":"#双向数据绑定的原理","children":[]},{"level":2,"title":"使用 Object.defineProperty() 来进行数据劫持有什么缺点","slug":"使用-object-defineproperty-来进行数据劫持有什么缺点","link":"#使用-object-defineproperty-来进行数据劫持有什么缺点","children":[]},{"level":2,"title":"⭐ computed 和 watch 的区别","slug":"computed-和-watch-的区别","link":"#computed-和-watch-的区别","children":[{"level":3,"title":"computed","slug":"computed","link":"#computed","children":[]},{"level":3,"title":"watch","slug":"watch","link":"#watch","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":3,"title":"场景","slug":"场景","link":"#场景","children":[]}]},{"level":2,"title":"computed 和 methods 的区别","slug":"computed-和-methods-的区别","link":"#computed-和-methods-的区别","children":[]},{"level":2,"title":"data为什么是一个函数而不是对象","slug":"data为什么是一个函数而不是对象","link":"#data为什么是一个函数而不是对象","children":[]},{"level":2,"title":"⭐ 对keep-alive的理解","slug":"对keep-alive的理解","link":"#对keep-alive的理解","children":[{"level":3,"title":"特点","slug":"特点","link":"#特点","children":[]},{"level":3,"title":"主要流程","slug":"主要流程","link":"#主要流程","children":[]},{"level":3,"title":"LRU缓存策略","slug":"lru缓存策略","link":"#lru缓存策略","children":[]}]},{"level":2,"title":"⭐ $nextTick的原理及使用场景","slug":"nexttick的原理及使用场景","link":"#nexttick的原理及使用场景","children":[{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":3,"title":"存在的原因","slug":"存在的原因","link":"#存在的原因","children":[]},{"level":3,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]}]},{"level":2,"title":"data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？","slug":"data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗","link":"#data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗","children":[]},{"level":2,"title":"⭐ 组件通信的方法","slug":"组件通信的方法","link":"#组件通信的方法","children":[{"level":3,"title":"父子组件间通信","slug":"父子组件间通信","link":"#父子组件间通信","children":[]},{"level":3,"title":"兄弟组件间通信","slug":"兄弟组件间通信","link":"#兄弟组件间通信","children":[]},{"level":3,"title":"任意组件之间","slug":"任意组件之间","link":"#任意组件之间","children":[]}]},{"level":2,"title":"Vue-router 导航守卫有哪些？","slug":"vue-router-导航守卫有哪些","link":"#vue-router-导航守卫有哪些","children":[]},{"level":2,"title":"Vue3有哪些更新？","slug":"vue3有哪些更新","link":"#vue3有哪些更新","children":[{"level":3,"title":"监测机制的改变","slug":"监测机制的改变","link":"#监测机制的改变","children":[]},{"level":3,"title":"模板","slug":"模板","link":"#模板","children":[]},{"level":3,"title":"对象式的组件声明方式","slug":"对象式的组件声明方式","link":"#对象式的组件声明方式","children":[]},{"level":3,"title":"其他改变","slug":"其他改变","link":"#其他改变","children":[]}]},{"level":2,"title":"Composition API","slug":"composition-api","link":"#composition-api","children":[{"level":3,"title":"产生的原因","slug":"产生的原因","link":"#产生的原因","children":[]},{"level":3,"title":"与React Hooks的区别","slug":"与react-hooks的区别","link":"#与react-hooks的区别","children":[]}]}],"git":{"createdTime":1708253141000,"updatedTime":1708337950000,"contributors":[{"name":"LuoHuacheng","email":"154224099@qq.com","commits":2}]},"readingTime":{"minutes":13.3,"words":3989},"filePathRelative":"interview/details/3-vue.md","localizedDate":"2024年2月18日","autoDesc":true}');export{p as comp,u as data};

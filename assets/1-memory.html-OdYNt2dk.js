import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as l,c as i,e as a}from"./app-D0SJy2ik.js";const t={},n=a(`<h1 id="内存-堆栈" tabindex="-1"><a class="header-anchor" href="#内存-堆栈"><span>内存/堆栈</span></a></h1><h2 id="类型" tabindex="-1"><a class="header-anchor" href="#类型"><span>类型</span></a></h2><ul><li><p>stack栈(LIFO，后进先出)</p><p>基本类型: 占用内存空间大小固定，按值直接访问</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> boolean<span class="token punctuation">,</span> number<span class="token punctuation">,</span> string<span class="token punctuation">,</span> symbol
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>heap堆(key-value，顺序无关)</p><p>引用类型: 占用内存空间大小不固定但内存地址大小固定，内存地址存储于栈中，访问时先从栈内读取内存地址，再从堆中寻找对应值</p></li><li><p>池(一般归为栈中，存放常量用)</p></li><li><p>队列(FIFO，先进先出)</p></li></ul><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期"><span>生命周期</span></a></h2><ul><li><p>栈: 自动分配，自动释放</p></li><li><p>堆: 手动分配，手动释放</p></li></ul><ol><li><p>分配所需内存</p></li><li><p>使用分配到的内存进行读写操作</p></li><li><p>读写完毕，释放内存(垃圾回收)</p></li></ol><h2 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收"><span>垃圾回收</span></a></h2><ul><li><p>标记清除(主流)</p><p>从根部（全局对象）出发定时扫描内存中的对象，若能从根部到达则保留，反之标记为不再使用，稍后进行统一回收</p></li><li><p>引用计数(大多已废弃，致命问题：循环引用)</p><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就不可再被访问，因此可以被回收</p></li><li><p>变量类型</p><ul><li>局部变量(局部作用域中，函数执行完就可回收局部变量)</li><li>全局变量(全局作用域中很难判断何时回收，因此要避免使用全局变量)</li><li>无需计入垃圾回收的变量类型(WeakSet / WeakMap)</li></ul></li></ul><h2 id="内存泄漏" tabindex="-1"><a class="header-anchor" href="#内存泄漏"><span>内存泄漏</span></a></h2><blockquote><p>对于持续运行的服务进程（daemon）必须及时释放无需用到的内存，否则内存占用越来越高，轻则影响性能，重则进程崩溃</p></blockquote><h3 id="排查方法" tabindex="-1"><a class="header-anchor" href="#排查方法"><span>排查方法</span></a></h3><ul><li><p>浏览器</p><ol><li>打开开发者工具，选择 Memory</li><li>在右侧的 Select profiling type 中勾选 timeline</li><li>点击左上角的录制按钮</li><li>在页面上模拟正常用户的各种操作</li><li>一段时间后，点击左上角的stop按钮，然后查看面板上这段时间内的内存使用情况</li></ol></li><li><p>Node.js</p><ol><li>使用 nodejs 提供的 process.memoryUsage()</li><li>以 heapUsed 字段来判定内存泄漏</li></ol></li></ul><h3 id="常见原因" tabindex="-1"><a class="header-anchor" href="#常见原因"><span>常见原因</span></a></h3><ul><li><p>意外的全局变量</p><ul><li>未定义的变量会在全局对象下创建一个新变量或函数内的 this 在调用时指向了全局对象</li><li>若必须使用全局变量存储数据，要确保使用完之后设置为 null，或重新定义；使用 use strict 严格模式，此时调用函数内本来指向全局的 this 会指向 undefined，从而避免意外的全局变量</li></ul></li><li><p>被遗忘的计时器或回调函数</p><ul><li>设置计时器后没有清除或DOM事件的循环引用</li><li>及时清除不再使用的计时器；addEventListener 之后若关联的对象不再使用需要调用 removeEventListener 解绑事件（针对引用计数的老IE，现代浏览器使用标记清除，可以不必调用）</li></ul></li><li><p>脱离 DOM 的引用</p><ul><li>将获取到的DOM存储成字典（JSON键值对）或者数组，此时同样的DOM元素会存在两个引用，一个在DOM树中，一个在字典中</li><li>DOM树与字典中的引用都需要清除掉</li></ul></li><li><p>闭包</p><ul><li>闭包的函数体内会存在对上层作用域中变量的引用，此时若上层作用域中的变量被释放，那么闭包中的变量也会被释放，从而导致内存泄漏</li><li>及时释放不再使用的闭包</li></ul></li></ul>`,14),p=[n];function s(o,r){return l(),i("div",null,p)}const h=e(t,[["render",s],["__file","1-memory.html.vue"]]),u=JSON.parse('{"path":"/js-book/1-memory.html","title":"内存/堆栈","lang":"zh-CN","frontmatter":{"category":"JS","description":"内存/堆栈 类型 stack栈(LIFO，后进先出) 基本类型: 占用内存空间大小固定，按值直接访问 heap堆(key-value，顺序无关) 引用类型: 占用内存空间大小不固定但内存地址大小固定，内存地址存储于栈中，访问时先从栈内读取内存地址，再从堆中寻找对应值 池(一般归为栈中，存放常量用) 队列(FIFO，先进先出) 生命周期 栈: 自动分配，...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/my-docs/js-book/1-memory.html"}],["meta",{"property":"og:site_name","content":"HC的前端手册"}],["meta",{"property":"og:title","content":"内存/堆栈"}],["meta",{"property":"og:description","content":"内存/堆栈 类型 stack栈(LIFO，后进先出) 基本类型: 占用内存空间大小固定，按值直接访问 heap堆(key-value，顺序无关) 引用类型: 占用内存空间大小不固定但内存地址大小固定，内存地址存储于栈中，访问时先从栈内读取内存地址，再从堆中寻找对应值 池(一般归为栈中，存放常量用) 队列(FIFO，先进先出) 生命周期 栈: 自动分配，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-18T10:45:41.000Z"}],["meta",{"property":"article:author","content":"Mr.HC"}],["meta",{"property":"article:modified_time","content":"2024-02-18T10:45:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内存/堆栈\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-18T10:45:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.HC\\"}]}"]]},"headers":[{"level":2,"title":"类型","slug":"类型","link":"#类型","children":[]},{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[]},{"level":2,"title":"垃圾回收","slug":"垃圾回收","link":"#垃圾回收","children":[]},{"level":2,"title":"内存泄漏","slug":"内存泄漏","link":"#内存泄漏","children":[{"level":3,"title":"排查方法","slug":"排查方法","link":"#排查方法","children":[]},{"level":3,"title":"常见原因","slug":"常见原因","link":"#常见原因","children":[]}]}],"git":{"createdTime":1708253141000,"updatedTime":1708253141000,"contributors":[{"name":"LuoHuacheng","email":"154224099@qq.com","commits":1}]},"readingTime":{"minutes":3.01,"words":904},"filePathRelative":"js-book/1-memory.md","localizedDate":"2024年2月18日","autoDesc":true}');export{h as comp,u as data};

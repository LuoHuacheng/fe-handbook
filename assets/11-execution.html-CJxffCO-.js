import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as o,e as i}from"./app-D0SJy2ik.js";const a={},c=i('<h1 id="js-运行机制" tabindex="-1"><a class="header-anchor" href="#js-运行机制"><span>JS 运行机制</span></a></h1><div class="hint-container tip"><p class="hint-container-title">提示</p><p>单线程？任务队列？事件循环？</p></div><h2 id="单线程" tabindex="-1"><a class="header-anchor" href="#单线程"><span>单线程</span></a></h2><p>在 JS 引擎中，解析执行 JS 代码的调用栈是唯一的，所有的 JS 代码都在这一个调用栈里按照调用顺序执行，不能同时执行多个函数，调用栈遵循 LIFO(last in first out 后进先出)的规则，只有栈顶的函数处理完成后出栈，后面的函数再进入栈顶被执行。</p><h2 id="任务队列" tabindex="-1"><a class="header-anchor" href="#任务队列"><span>任务队列</span></a></h2><p>由于 JS 引擎的单线程设定同一时间只能执行一个任务，所有的任务都需要排队等待被引擎执行，所以如果其中某个任务耗时很长，后面的任务就必须一直等待，为解决这一问题，设计者将所有任务分为两种，同步与异步。</p><p>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</p><p>异步任务：不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>异步任务一般有：</p><ul><li><code>setTimeout(fn, time)</code>、<code>setInterval(fn, time)</code><ul><li>当 <code>time</code> 参数值缺省时，默认为 0</li><li>当 <code>time</code> 指定的值小于 4 时，增加到 4，即至少需要 4 毫秒，此定时器才会进入任务队列</li></ul></li><li>DOM 事件</li><li>Ajax 异步与 Promise</li></ul><p><mark>在所有同步任务执行完之前，任何的异步任务是不会执行的</mark></p><h2 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环"><span>事件循环</span></a></h2><p>异步任务的执行机制：</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈(execution context stack)</li><li>主线程之外，还存在一个&quot;任务队列&quot;(task queue)，只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件</li><li>一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件，那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行</li><li>主线程不断重复上面的第三步</li></ol><p><mark>主线程从&quot;任务队列&quot;中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。只要主线程空了，就会去读取&quot;任务队列&quot;，这就是 JavaScript 的运行机制。</mark></p><h2 id="异步任务分类" tabindex="-1"><a class="header-anchor" href="#异步任务分类"><span>异步任务分类</span></a></h2><p>异步任务可以分为宏任务和微任务，宏任务队列可以有多个，微任务队列只有一个。</p><p>宏任务: <code>script(整体代码)</code>，<code>setTimeout</code>，<code>setInterval</code>，<code>setImmediate</code>(Node)，<code>I/O</code>，<code>UI rendering</code>，<code>postMessage</code></p><p>微任务: <code>new Promise().then(回调)</code>，<code>process.nextTick</code>，<code>Object.observe</code> (已废弃)，<code>MutationObserver</code> (html5 新特性)</p><p>执行顺序：</p><ol><li>由于执行代码入口都是全局任务 <code>script</code>，而全局任务属于宏任务，所以先执行宏任务。当栈为空，同步任务执行完毕时，会先执行微任务队列里的任务</li><li>微任务队列里的任务全部执行完毕后，会读取宏任务队列中排队最前的任务</li><li>执行宏任务的过程中，遇到微任务，依次加入微任务队列</li><li>栈空后，再次读取微任务队列里的任务，依次类推</li></ol><p><mark>当某个宏任务队列的中的任务全部执行完以后，会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，就查看是否有其他宏任务队列</mark></p>',22),n=[c];function r(l,p){return t(),o("div",null,n)}const u=e(a,[["render",r],["__file","11-execution.html.vue"]]),m=JSON.parse('{"path":"/interview/outline/11-execution.html","title":"JS 运行机制","lang":"zh-CN","frontmatter":{"category":"Javascript","description":"JS 运行机制 提示 单线程？任务队列？事件循环？ 单线程 在 JS 引擎中，解析执行 JS 代码的调用栈是唯一的，所有的 JS 代码都在这一个调用栈里按照调用顺序执行，不能同时执行多个函数，调用栈遵循 LIFO(last in first out 后进先出)的规则，只有栈顶的函数处理完成后出栈，后面的函数再进入栈顶被执行。 任务队列 由于 JS 引擎...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/my-docs/interview/outline/11-execution.html"}],["meta",{"property":"og:site_name","content":"HC的前端手册"}],["meta",{"property":"og:title","content":"JS 运行机制"}],["meta",{"property":"og:description","content":"JS 运行机制 提示 单线程？任务队列？事件循环？ 单线程 在 JS 引擎中，解析执行 JS 代码的调用栈是唯一的，所有的 JS 代码都在这一个调用栈里按照调用顺序执行，不能同时执行多个函数，调用栈遵循 LIFO(last in first out 后进先出)的规则，只有栈顶的函数处理完成后出栈，后面的函数再进入栈顶被执行。 任务队列 由于 JS 引擎..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-18T10:45:41.000Z"}],["meta",{"property":"article:author","content":"Mr.HC"}],["meta",{"property":"article:modified_time","content":"2024-02-18T10:45:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JS 运行机制\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-18T10:45:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.HC\\"}]}"]]},"headers":[{"level":2,"title":"单线程","slug":"单线程","link":"#单线程","children":[]},{"level":2,"title":"任务队列","slug":"任务队列","link":"#任务队列","children":[]},{"level":2,"title":"事件循环","slug":"事件循环","link":"#事件循环","children":[]},{"level":2,"title":"异步任务分类","slug":"异步任务分类","link":"#异步任务分类","children":[]}],"git":{"createdTime":1708253141000,"updatedTime":1708253141000,"contributors":[{"name":"LuoHuacheng","email":"154224099@qq.com","commits":1}]},"readingTime":{"minutes":3.01,"words":904},"filePathRelative":"interview/outline/11-execution.md","localizedDate":"2024年2月18日","autoDesc":true}');export{u as comp,m as data};
